\chapter{Mutated checking}\label{sec:ch4}

\info{intro}

\section{Method}

The lightweight version from the previous chapter is only able to one specific
bug, the bug itself is created by manually modifying the generated system. Now,
this lightweight version needs to be automated to automatically generate a test
for every transition from a specification.

With every transition, it is possible to reach a state or stay in the current
state. To check \textit{Rebel} specifications, the state to reach with a transition needs
to be defined. As mentioned before, the goal of model checking is to find a
state which is reachable with some properties which don't hold
~\cite[p.5]{stoel_storm_vinju_bosman_2016}. Thus defining only the reachable
state isn't enough, the properties of interest for a transition needs to be
specified. Each property is different per transition, so these properties should
be different for the defined state. For example for the \textit{close}
transition, we want to check whether it is possible to have an closed account
where the balance isn't equal to zero, for the transition \textit{withdraw} we
want to check whether a negative balance can be achieved with the transition.

To conclude, with this approach we're testing the inverse of the preconditions. Thus we're testing
what should not be possible according to the specification.

\subsection{Evaluation criteria}
Evaluation points and expectations.

\subsubsection{Bugs}
Find bugs where the inverse is possible. Just like the example from the test
mechanics.

\subsubsection{Efficiency}
Test similar as the SMT. Testing the right transition

\subsubsection{Coverage}
To test all transitions with its state.

\section{Approach}
This is a well known approach in mutation testing. Mutation testing is
fault-based testing technique, which generates faulty programs by syntactic
changes to the original program.~\cite[p.~1]{jia2011analysis} The set of faulty
programs are called mutants, each mutant contains a different syntactic change.
In our case, only one mutant is generated. A test suite for a program is used to
determine whether the faulty programs are detected. A mutant is killed when it
is detected by the test suite. The mutant is in our case killed when the result
from the SMT Solver and the SUT are the same. We're using the same
approach from \autoref{sec:ch3} to compare the results of the SMT solver and
SUT.

Mutation testing generates a mutant based on
mutation operator, which is a transformation rule that generates a mutant from
the original program.~\cite[p.~3-4]{jia2011analysis} The mutation operator for
our approach is Negate Conditionals Mutator~\cite{pitmutators}, this operator
belongs to the type relational operator
replacement~\cite[p.~688]{king1991fortran}.

\info{add image}

\subsection{Checking}
Only expressions which contain a reference to the specification fields needs to
be replaced since it is only possible in tebl to specify the reachable state
with the properties of interest (these properties are not part of the
transition).

Earlier the definition of the \textit{close} event transition was given in
\autoref{fig:account-close-event} which contains the following statement
\code{this.balance == EUR 0.00;}. When this statement is translated to tebl
with a negated conditional, it looks as follows
\code{balance != EUR 0.00;}. Thus the replaced conditional is the inverse
condition of the statement defined in the \textit{close} transition.

Replacing conditionals to negated contionals is done for all conditionals with
relational operators. The chosen mutation operator Negate Conditionals Mutator
will replace conditionals according to the replacement table in
\autoref{fig:table-replacement-conditions}.

\begin{table}[h!]
\centering
\begin{tabular}{cc}
\textbf{Actual expression} & \textbf{Translated expression} \\
!=                         & ==                             \\
==                         & !=                             \\
\textgreater               & \textless=                     \\
\textgreater=              & \textless                      \\
\textless                  & \textgreater=                  \\
\textless=                 & \textgreater                   \\
\end{tabular}
\caption{Conditionals replacement}\label{fig:table-replacement-conditions}
\end{table}

\subsection{Generated system}
The conditionals for the transition in the SUT are also replaced.
Although, it isn't necessary to replace always the conditionals. For some
transitions is an initial state required, \textit{e.g.}, to execute the transition unblock
of the account specification, the account should be in the state blocked. So an
initial state needs to be constructed for some transitions. Of course, the SMT
solver is able to construct its own initial state to reach a state.

The definition of the \textit{deposit} transition is given in
\autoref{fig:account-deposit-event} and contains the following statement in the
preconditions \code{amount > EUR 0.00;}. First, the initial state needs to be
constructed which is the state opened. Following is the replacement of the conditionals, so the
following statement from the \textit{deposit} definition \code{amount > EUR 0.00;} is
replaced. Then the \textit{deposit} transition needs to be performed in the SUT.

To perform the \textit{deposit} transition, the transition parameters for this
transition must be determined satisfying replaced conditionals. The transition
parameter for the \textit{deposit} transition, amount, should should be less
than or equal to 0 euro. Therefore, are generators implemented to generate
values satisfying the negated conditionals. For example, the following
transition parameter is generated to be used in the \textit{deposit} transition
\code{"amount": "EUR -2.00"}.

\begin{sourcecode}[h!]
\begin{lstlisting}[]
event deposit(amount: Money) {
	preconditions {
		amount > EUR 0.00;
	}
	postconditions {
		new this.balance == this.balance + amount;
	}
}
\end{lstlisting}
\caption{deposit event definition from specification}\label{fig:account-deposit-event}
\end{sourcecode}

\section{Results}
Discuss the results of the test approach.

\subsection{Codegen-Akka}

\begin{table}[h!]
\centering
\begin{tabular}{cc}
\toprule
\textbf{Transition to test} & \textbf{Transition} \\ \midrule
openAccount                 & \cmark{}            \\
withdraw                    & \xmark{}            \\
deposit                     & \xmark{}            \\
interest                    & \cmark{}            \\
block                       & \cmark{}            \\
unblock                     & \cmark{}            \\
close                       & \xmark{}            \\ \bottomrule
\end{tabular}
\caption{Results: testing account specification transitions}\label{fig:ch5-res-codegenakka-account}
\end{table}

\section{Analyse}
Analyse of the results

\subsection{Codegen-Akka}
The proof of concept uses in this test run the Codegen-Akka generator.

% https://github.com/cwi-swat/ing-rebel-generators/commit/999e6b40307a79fb245ace15375c27461c92374e
\subsubsection{Bug: closing an account with balance}\label{sec:bug-close-account}
When this automated version of checking is executed, it produces some false
positives. After investigating the tests for the transitions, the test for the \textit{close}
transition seems not be successful (see \autoref{fig:result-close-account}).
According to the model checker, it seems to be that the state isn't reachable
(the same tebl file is generated as in \autoref{fig:tebl-closed-account}). It
seems to be that the state is reachable in the SUT.

\begin{sourcecode}[h!]
\begin{lstlisting}[]
Test transition close
opened -> close -> closed
generated close test in |project://rebel-core/examples/simple_transaction/OpenedToClosedViaCloseTest.tebl|

Reachability transition: false
Execute transition result: true
Result successful transition test: false
\end{lstlisting}
\caption{Result run}\label{fig:result-close-account}
\end{sourcecode}

When we take a look at the account in the SUT, the account looks as
follows in \autoref{fig:closed-account-json}. The state of the account is in
closed, which is correct according to the specification, but the balance of the
account is 52 euro. In \autoref{fig:account-close-event} we already discussed
the event  definition of the \textit{close} transition, which is that the
balance should be equal to zero. From this, we can conclude that we've
discovered a bug in the SUT.

\begin{sourcecode}[h!]
\begin{lstlisting}[]
[{
	"_id": 17592186045441,
	"_version": 2,
	"_status": "CLOSED",
	"accountNumber": {
		"iban": "NO3627716652225"
	},
	"balance": {
		"value": 52.00,
		"currency": "EUR"
	}
}]
\end{lstlisting}
\caption{account state in json}\label{fig:closed-account-json}
\end{sourcecode}

Now we know that we have discovered a bug, we want to know where this takes
place and whether the code isn't generated correctly from the specification. The
method which handles the \textit{close} transition has the following check in
\autoref{fig:java-notequal-check}. The if statement checks whether the balance
of the account is not equal to 0 euro. The condition in the if statement isn't
satisfied with the balance of 52 euro. That's why the exception
\textit{BuildCASTransactionException} isn't thrown.

\begin{sourcecode}[h!]
\begin{lstlisting}[language=Java]
if(! (isNotEqual(_entity.getBalance(), Money.of(org.joda.money.CurrencyUnit.of("EUR"), 0.00)))) {
  throw new BuildCASTransactionException("Predicate did not hold: CloseTransaction: this.balance ==
  EUR 0.00");
}
\end{lstlisting}
\caption{Code in Java}\label{fig:java-notequal-check}
\end{sourcecode}

The question right now is, how is the above code generated. After taking a look at the synthesization of
expression, the expressions from \textit{Rebel} are not properly translated. The
synthesization for an equal expression for the type \textit{Money} or \textit{Percentage} looks as
follows in \autoref{fig:rascal-datomic-synthesize-equal}. The expression is
synthesized to the method \textit{isNotEqual} with two parameters.

\begin{sourcecode}[h!]
\begin{lstlisting}[]
private str g(e:(Expr)`<Expr lhs> == <Expr rhs>`, tmap t) = "isNotEqual(<g(lhs, t)>, <g(rhs, t)>)"
  when isType(t, lhs, (Type)`Percentage`) || isType(t, lhs, (Type)`Money`);
\end{lstlisting}
\caption{Generate equal expression in Rascal}\label{fig:rascal-datomic-synthesize-equal}
\end{sourcecode}

So the expression isn't properly synthesized, and it should be synthesized to
\textit{isEqual} instead of \textit{isNotEqual}. With this modification, it
isn't possible anymore to close an account with some balance (this also applies
to other expressions of the type equal).

% https://github.com/cwi-swat/ing-rebel-generators/pull/6
\subsubsection{Bug: deposit with a maximum amount}\label{sec:bug-compile-max-deposit}

The automated checking is implemented with the ability to first start the
SUT and then run the tests against it. For a new test run, the
specification has changed a little bit. It is now possible to only deposit with
a maximum amount (see \autoref{fig:java-deposit-maxamount}). After the code is
generated, the testing framework isn't able to start the system. There is a
compile error as you can see in
\autoref{fig:java-result-lessthan-compile-error}, the binary operator "$<$"
isn't applicable on the type \textit{org.joda.money.Money}. The compile error
is thrown by the source code from \autoref{fig:java-lessthan-compile-error},
which is part of the method which handles the \textit{deposit} transition.

% less than, not compilable. Duplicate method for greaterThan should be lessThan

\begin{sourcecode}[h!]
\begin{lstlisting}[]
event deposit(amount: Money) {
	preconditions {
		amount < EUR 250.00;
	}
	postconditions {
		new this.balance == this.balance + amount;
	}
}
\end{lstlisting}
\caption{deposit event definition from specification}\label{fig:java-deposit-maxamount}
\end{sourcecode}

\begin{sourcecode}[h!]
\begin{lstlisting}[]
Error:(63, 23) java: bad operand types for binary operator '<'
  first type:  org.joda.money.Money
  second type: org.joda.money.Money
\end{lstlisting}
\caption{deposit event definition from specification}\label{fig:java-result-lessthan-compile-error}
\end{sourcecode}

\begin{sourcecode}[h!]
\begin{lstlisting}[language=Java]
if(! ((amount < Money.of(org.joda.money.CurrencyUnit.of("EUR"), 200.00)))) {
  throw new BuildCASTransactionException("Predicate did not hold: DepositTransaction:
  amount < EUR 250.00");
}
\end{lstlisting}
\caption{Code in Java}\label{fig:java-lessthan-compile-error}
\end{sourcecode}

The synthesization of the generated is shown in
\autoref{fig:rascal-datomic-synthesize-lessthan}. Also here are the \textit{Rebel}
expression not properly translated. The default expression with the binary
operator "$<$" is properly synthesized to an expression with three expressions,
the left-hand and right-hand side expression and the binary operator "$<$".
As discussed before, the binary operator "$<$" doesn't work with
\textit{org.joda.money.Money}. Thus the default method to synthesize expressions
with the binary operator "$<$" cannot be used for the type
\textit{org.joda.money.Money}.

On line number 1 of \autoref{fig:rascal-datomic-synthesize-lessthan} is the
synthesization method of the expression with the binary operator "$>$" shown.
This method is already defined before in the corresponding file, so this is a
typical copy paste fault. To conclude, this method should synthesize expressions
with the binary operator "$<$".

\begin{sourcecode}[h!]
\begin{lstlisting}[]
private str g(e:(Expr)`<Expr lhs> \> <Expr rhs>`, tmap t) = "isGreaterThan(<g(lhs, t)>, <g(rhs, t)>)"
  when isType(t, lhs, (Type)`Percentage`) || isType(t, lhs, (Type)`Money`);
private str g(e:(Expr)`<Expr lhs> \< <Expr rhs>`, tmap t) = "(<g(lhs, t)> \< <g(rhs, t)>)";
\end{lstlisting}
\caption{Generate equal expression in Rascal}\label{fig:rascal-datomic-synthesize-lessthan}
\end{sourcecode}

\section{Evaluation}\label{sec:ch4-evaluation}

\subsection{Evalution points}
In this proof of concept is the account specification used to test the SUT.
This proof of concept generates automatically tests for transitions.

A part of
the generated test for a transition is checking, which is used to test the state to
reach with the replaced preconditions. So, in this proof of concept, we're
testing what should be not possible according to the specification. The result
of the checking from the SMT Solver varies, \textit{e.g.}, an opened account can be
reached by the \textit{openAccount} transition or by the transition
\textit{openAccount} and \textit{withdraw}.

After the checking, a transition
is performed in the SUT. In this proof of concept, it's unknown whether the
performed transition with its parameters in the SUT is the same as the
transition computed by the SMT Solver. This causes some false positives in the
test run. Also, it is difficult to play like the SMT Solver, it is unknown which
result the SMT Solver will give. The SMT solver is also smarter/better in checking
the satisfiability of a given constraints.

To conclude, the checking used in this proof of concept tests only the states, regardless of which transitions are
being performed, and testing the SUT focuses more on testing transitions.

With this proof of concept, we've found a bug in the SUT, which was
discussed in \autoref{sec:bug-close-account}. The other bug is out of scope
since the SUT isn't able to compile. The found bug belongs to the category
injected code since the generated code for the precondition is wrong. In this
case, the final state closed is reached where the preconditions of the \textit{close}
transition don't hold. So the theory for this found bug is:
$\forall e s_{1} \to s_{2}, s_{2} \gets s_{1}, pre(e)$.

% claims from finding the bugs.

% \begin{itemize}
% \item je bent in een state gekomen via een preconditie
% \item de transitie zelf verander de pre conditie niet, (de preconditie geldt dan in de postconditie)
% \item het was de laatste

% \item $\forall e s1 \to s2, in s2 geldt pre(e) \lor (! pre(e) \land post(e))$
% \item $\forall e s1 \to s2, in s2 post(e)$
% % of?
% \item $\forall e s1 \to s2, s2 alleen bereikbaar via (1), dan pre(e)$
% \end{itemize}

\subsection{Conclusion}
Conclusion

\section{Threats to validity}

\subsection*{Limited specifications}
In the conducted experiments are the specifications account and transaction used
to test the generated system from these specifications. With these experiments
and specifications, we did find faults in the code generators. Although are
these specifications quite simple, \textit{e.g.}, for a bank these
specifications would be more complex. These experiments take into account the
generosity of specifications, but with such a large amount of complex
specifications, it is questionable whether these experiments still produce
valuable results.

\subsection*{Rebel interpretation in SMT Solver}
The SMT solver can be seen as an interpreter for Rebel specifications. The
conducted experiments use the SMT solver to test the generated systems from the
specifications. We already discussed before the limitation of interpretation of
Rebel specifications, and in some cases, workarounds have been used. There may
be more unknown limitations of the interpretation of Rebel specifications, which
can cause the conducted experiments give incorrect results.

\subsection*{Valid execution trace}
The experiment from \autoref{sec:ch5} tests only valid execution traces from
the SMT solver, \textit{i.e.}, testing only what should be possible according to
the specification. Testing valid execution traces is not enough, testing not
valid execution traces can be valuable. Thus the experiment from
\autoref{sec:ch4} already does this, but as discussed it has a few limitations.
