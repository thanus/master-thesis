\chapter{Conclusion}\label{sec:ch7}

In this work, we have shown two proof of concepts to test generated systems from
\textit{Rebel} specifications. With these proof of concepts, it can be tested
whether the generated systems are generated properly based on \textit{Rebel}
specifications. The result of this is that we regained the benefits from
\textit{Rebel} domain, and again able to test and reason about \textit{Rebel}
specifications and generated system.

\begin{quote}
  \textbf{How to validate the generated code from a Rebel specification?}
\end{quote}

In an earlier study~\cite[p.3]{stoel2015case}, the author proposed a possible
solution, which is to use the \gls{smt} solver to test generated systems.
In both proofs of concepts, the \gls{smt} solver holds the key in testing the
generated systems.

The generated systems are tested in two ways, invalid execution and valid execution.
The first experiment tests invalid execution in the generated systems, \textit{i.e.},
testing what should be not possible according to the specification.
Therefore, the test framework uses checking to check the satisfiability for a
transition from the specification, and then test this in the \gls{sut}.
In this experiment is a mutation operator, which is used in mutation testing,
applied to test invalid execution.
This experiment has its limitations due to the inability to use traces
since with checking traces are not available when a state is not reachable.
With this experiment, we did find two faults in
the \gls{sut}; only one fault is within the research scope.

The second experiment tests valid execution in the generated systems,
\textit{i.e.}, testing what should be possible according to the specification.
This experiment uses two existing testing techniques within \textit{Rebel} to
generate tests for transitions, namely checking and simulation.
The traces from this are used to test \gls{sut} in this experiment.
In this experiment is a model-based testing approach taken to check whether the
\gls{sut} accepts the execution from traces whether the \gls{sut} behaves as the
specification.
Even the transition parameters data values are generated by the SMT solver which
satisfies the constraints of the transition. The limitation of this experiment
is that it is not possible to test all transitions. This experiment is only able
to test transitions when the preconditions of a given transition are satisfied
by the current state.
With this experiment, we did find
three faults in the \gls{sut}; one fault is identified by a slightly different test
approach to find distribution faults.

To sum up, with the experiments a total of five faults have been found in the
generated system that is generated by the code generators.
These faults can be categorised in the following categories: templating,
compilation and distribution.

\clearpage

\section{Future work}

\subsubsection{Mutation model-based testing}

The first experiment has its limitations due to the inability to use traces
since with checking traces are not available when a state is not reachable.
Instead of applying mutation testing on the execution transition in the
\gls{sut}, it can be applied to the \textit{Rebel} specification.
The study \cite{paradkar2005case} reports that model-based testing technique
using mutation has valuable fault detection effectiveness.
Traces are also available with this approach since only the specification is
mutated and it can be interpreted by the \gls{smt} solver.
These traces can be used to test the generated systems, which allows this
approach to be combined with the second experiment. As a result, the limitation
of this experiment is solved with the use of \gls{smt} solver.

\subsubsection{Bounded checking}

Model checking \textit{Rebel} specifications is bounded. The bounded analysis is
used to find the smallest possible counterexample.~\cite[p.~5]{stoel_storm_vinju_bosman_2016}
Finding a counterexample is automatic and incremental,
\textit{i.e.} check incremental whether an invalid state can be reached in
steps until a counterexample is found or the configuration timeout is reached.
The configuration timeout can also be found in the experiments.
Determining this value has been left as a future work.
In determining this value, two aspects should be taken into account,
namely risk and time. For high-risk systems, a higher configuration timeout can
be used to test more extensively. On the other hand, due to a high configuration
timeout, testing can be time-consuming.

\subsubsection{Invalid current state}

The second experiment tests valid execution in the generated systems, with the
use of existing testing techniques within \textit{Rebel} to generate tests for
transitions, namely checking and simulation. The intention of this experiment is
to test all transitions, but it is only possible to test transitions when the
preconditions of a given transition are satisfied by the current state.
As a result, the simulation is not able to simulate some transitions.
To test all transitions, this should be solved. Taking into account, the
preconditions which should hold in the current state can be solved by the test
framework or the \gls{smt} solver. Although it is better to solve this by the
\gls{smt} solver as this is one of the purposes of the \gls{smt} solver.

\subsubsection{More complex specifications}

In the conducted experiments are only the specifications account or combined
with the transaction specification used to test the \gls{sut} from these
specifications. With these experiments and specifications, we did find faults in
the generated systems and the code generators. Although these specifications are
quite simple, \textit{e.g.}, the specifications within a bank would be more
complex. With such a large amount of complex specifications, the chance is
bigger to find faults in the code generators since the specifications are
interacting more with each other.
This also affects the testing of distributed systems. In our approach, a
simple approach has been chosen for testing distributed systems. To find faults
like deadlock and race conditions sufficient communication is needed.
