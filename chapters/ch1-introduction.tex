\chapter{Introduction}

\epigraph{Discovering the unexpected is more important than confirming the
known.}{George E. P. Box}

Growing systems is a concern for large
organisations.~\cite[p.~1]{stoel_storm_vinju_bosman_2016} The continuity of
systems becomes difficult and a single modification can result in unexpected
behaviour of a larger part of the system.

Within the domain knowledge, reasoning about the expected behaviour of a system,
changes and errors are hard. \textit{Rebel} aims to solve these challenges by centralising the domain knowledge and relating
it to the running systems. \textit{Rebel} is a formal specification language which is
used for controlling the intrinsic complexity of software for financial
enterprise systems.~\cite[p.~1]{stoel_storm_vinju_bosman_2016}

Software testing is an important part in software projects.~\cite[p.~4]{myers2011art} The testing
process within large systems can be challenging, it entails not only defining
and executing a lot of test cases, solving thousands of errors, handling
thousands of modules, but also enormous project management. To facilitate this
process \textit{Rebel} offers automated simulation and checking of specifications with
the use of a Satisfiability Modulo Theories (SMT) solver. This solves to some
extent the testing and reasoning of \textit{Rebel} specifications, but this is only
within in the \textit{Rebel} domain.

With the use of code generators, code can be
generated from \textit{Rebel} specifications. The problem with code generation is that the resulting
product is leaving the \textit{Rebel} domain, causing loss of testing and reasoning with
the use of formal methods. The challenge is to regain the benefits from the
\textit{Rebel} domain to be able to test and reason about running systems.
% The challenge is to regain the benefits from the \textit{Rebel} domain to be able to test and reason about systems with the use of formal methods.

\section{Problem statement}\label{sec:problem-statement}

% Ultimately, running systems should be generated from \textit{Rebel} specifications. Since \textit{Rebel} is a declarative language it will not always be straightforward to generate a correct system from this. Again SMT solvers might hold the key as shown in other work like [9].

According to the study~\cite[p.~3]{stoelcase} it should be possible to generate
running systems from \textit{Rebel} specifications. Right now this is possible and
running systems are generated from \textit{Rebel} specifications. It isn't always straightforward to generate a correct system from \textit{Rebel}
specifications since \textit{Rebel} is a declarative language.~\cite[p.~3]{stoelcase}
As mentioned before, the simulation and checking for the correctness of
specifications is only in the \textit{Rebel} domain.

The running systems which are
generated from specifications need to be properly based on these specifications,
it should be conform to these specifications. So additional work is necessary for
the generation process to know that running systems are conform to the
specifications.

The language \textit{Rebel} promised to be deterministic, this also holds
for the generated system. So nondeterministic behaviour should be identified.

For ING Bank it is especially important that there is no corrupted data within
the runtime systems.

\subsection{Research questions}\label{sec:research-questions}
The following questions are defined to achieve the research goal:

\begin{description}
  \item [RQ] How to validate the generated code from a Rebel specification?

  \begin{description}
    \item [SQ1] How is the input/output of the generated system tested?
    \item [SQ2] Are there any false positives/negatives when the generated
    system has been implemented correctly?
    \item [SQ3] What kind of bugs can be found and what are the factors?
  \end{description}

\end{description}

\subsection{Research method}\label{sec:research-method}

The research is about testing the implementation correctness of specifications.
For the problems in \autoref{sec:problem-statement}, the
study~\cite[p.3]{stoelcase} proposed a possible solution for these problems,
which is to use SMT Solvers. As before mentioned, the mapping of the \textit{Rebel}
language to the SMT formulas makes it possible to check and simulate
specifications. Hereby, there is an interpreter for \textit{Rebel} specifications, which
is the SMT Solver.~\cite[p.5]{stoel_storm_vinju_bosman_2016}

In the same study,
an attempt of model based testing is done to test real banking systems.
According to the study, it is only possible to test interactively using the
simulation. The steps made in the simulation are executed in the SUT, any
differences in behaviour are displayed in the simulator. The future work of this
approach is to expand the functionality to work automatically with a given
trace.

Due to all these reasons, it seems to be a good solution to use the SMT
Solver which holds the key in testing the generated system. Theoretically, with
this approach, it is possible to regain the benefits from the \textit{Rebel} domain, and
again able to test and reason about \textit{Rebel} specifications and generated system.

The hypothesis is that the SMT Solver can be used to test the implementation
correctness of a specification against a generated system. In order to do this,
research needs to be carried out for testing the generated system
with the SMT Solver, mappings (traces) between these systems. With the given approach, a
few assumptions need to be made:

\begin{itemize}
\item \textbf{The specification is always correct.}
The specifications are written correctly, \textit{i.e.}, the specifications are
correctly modelled from the business point of view. An incorrect specification
will probably not pass the checking or simulation, and testing a generated
system derived from an incorrect specification isn't really effective.
\item \textbf{The generated system is able to be compiled.} When the generated
system cannot be compiled, it is possible that there might be a fault in the
code generator. Although, with this approach testing a not compilable system is
impossible.
\item \textbf{The \textit{Rebel} specifications are correctly interpreted by the SMT
Solver.} The SMT Solver is used as an oracle/black box in the testing approach
since it is an interpreter for \textit{Rebel} specification. However, when
something goes wrong with the mapping of the \textit{Rebel} language to the SMT
formulas, this will result into misbehaviour of the specification which may lead
to incorrect results.
\end{itemize}

At first, an initial lightweight version is expected, then it will be extended with motivated
improvements with evaluation and validation. The proof of concept is a testing
tool for testing the implementation correctness of a specification of SUT.

The
approach is to start with the lightweight version which can trigger a bug and
test it with the SMT Solver. For the lightweight version, it is an easily
reproducible bug. Then the lightweight version can be improved to a smarter
testing technique to automatically generate tests, these improvements are done
with evaluation and validation. For example, by using existing software testing
techniques like Concolic testing~\cite{sen2007concolic}, Fuzz testing~\cite{godefroid2008automated} and Mutation testing~\cite{jia2011analysis}.

\section{Contributions}
% The research has the following contributions:
%
% \begin{enumerate}
%   \item Tool for testing a generated system from a specification.
%   \item Limitations in \textit{Rebel} or SMT encoding.
%   \item Bugs and its categories.
%   \item Solved the future work of \textit{Rebel} paper
% \end{enumerate}

\section{Related Work}
\begin{itemize}
  \item Runtime verification
  \item Testing generated systems
\end{itemize}

\section{Outline}
This discussed the outline of this thesis.
