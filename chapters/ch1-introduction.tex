\chapter{Introduction}

\epigraph{Discovering the unexpected is more important than confirming the
known.}{George E. P. Box}

Growing systems is a concern for large organizations
\cite[p.1]{stoel_storm_vinju_bosman_2016}. The continuity of systems becomes
difficult and a single modification can result in unexpected behaviour of a
larger part of the system. Within the domain knowledge, reasoning about the
expected behaviour of a system, changes and errors are hard. Rebel aims to solve
these challenges by centralizing the domain knowledge and relating it to the
running systems. Rebel is a formal specification language which is used for
controlling the intrinsic complexity of software for financial enterprise
systems \cite[p.1]{stoel_storm_vinju_bosman_2016}.
Software testing is an important part in software projects
\cite[p.4]{myers2011art}. The testing process within large systems can be
challenging, it entails not only defining and executing a lot of test cases,
solving thousands of errors, handling thousands of modules, but also enormous
project management. To facilitate this process Rebel offers automated simulation
and checking of specifications with the use of a Satisfiability Modulo Theories
(SMT) solver. This solves to some extent the testing and reasoning of Rebel
specifications, but this is only within in the Rebel domain. With the use of
code generators, code can be generated from specifications. The problem with
code generation is the resulting product is leaving the Rebel domain, causing
loss of testing and reasoning with the use of formal methods.
The challenge is to regain the benefits from the Rebel domain to be able to test
and reason about running systems.
% The challenge is to regain the benefits from the Rebel domain to be able to test and reason about systems with the use of formal methods.

\section{Problem statement}
\label{sec:problem-statement}

% Ultimately, running systems should be generated from Rebel specifications. Since Rebel is a declarative language it will not always be straightforward to generate a correct system from this. Again SMT solvers might hold the key as shown in other work like [9].

According to the study \cite[p.3]{stoelcase} it should be possible to generate
running systems from Rebel specifications. Right now this is possible and
running systems are generated from Rebel specifications. As mentioned in the
study, it isn't always straightforward to generate a correct system from Rebel
specifications, since Rebel is a declarative language.
As mentioned before, the simulation and checking for the correctness of
specifications is only in the Rebel domain. The running systems which are
generated from specifications need to be properly based on these specifications,
it should conform to these specifications. So additional work is necessary for
the generation process to know that running systems are conforming to the
specifications. The language Rebel promised to be deterministic, this also holds
for the generated system. So non-deterministic behaviour should be identified.
For ING Bank it is especially important that there is no corrupted data within
the runtime systems \unsure{is dit nog nodig om te vermelden?}.

\subsection{Research questions}
\label{sec:research-questions}

\begin{description}
  \item [RQ] How do you efficiently find out whether the generated code conforms
  to the specification?

  \begin{description}
    \item [RQ1] How is the input/output of the generated system tested?
    \item [RQ2] Are there any false positives/negatives when the generated
    system has been implemented correctly?
    \item [RQ3] What kind of bugs can be found and what are the factors?
  \end{description}

\end{description}

\subsection{Research method}
\label{sec:research-method}

The research is about testing the implementation correctness of a specification.
For the problems in \autoref{sec:problem-statement}, the study
\cite[p.3]{stoelcase} proposed a possible solution for these problems, which is
to use SMT Solvers. As before mentioned, the mapping of the Rebel language to
the SMT formulas makes it possible to check and simulate specifications. Hereby,
there is an interpreter for Rebel specifications which is the SMT Solver
\cite[p.5]{stoel_storm_vinju_bosman_2016}. In the same study, an attempt of
model based testing is done to test real banking systems. According to the
 study, it is only possible to test interactively using the simulation. The
 steps made in the simulation are executed in the SUT, any differences in
 behaviour are displayed in the simulator. The future work of this approach is
 to expand the functionality to work automatically with a given trace. Due to
 all these reasons, it seems to be a good solution to use the SMT Solver which
 holds the key in testing the generated system. Theoretically, with this
 approach, it is possible to regain the benefits from the Rebel domain, and
 again able to test and reason about Rebel specifications and generated system.
 So the hypothesis is that the SMT Solver can be used to test the implementation
 correctness of a specification against a generated system. In order to do this,
 research needs to be carried to determine the input/output to generated system
 and SMT Solver, mapping of the input/output (traces), and to what extent does
 the comparison test the implementation correctness. With the given approach, a
 few assumptions need to be made:
\begin{itemize}
\item \textbf{The specification is always correct.} An incorrect specification
will probably not pass the checking or simulation, and testing a generated
system derived from an incorrect specification isn't really effective.
\info{vanuit human mind, correct opgeschreven}
\item \textbf{The generated system is able to be compiled.} When the generated
system cannot be compiled, it is possible that there might be a fault in the
code generator. Although, with this approach testing a not compilable system is
impossible.
\item \textbf{The Rebel specifications are correctly interpreted by the SMT
Solver.} The SMT Solver is used as an oracle/black box in the testing approach
since it is an interpreter for Rebel specification. However, when something goes
wrong with the mapping of the Rebel language to the SMT formulas, then there is
some misbehaviour of the specification in the SMT Solver.
\end{itemize}

At first, an initial "lightweight" version is expected, and then motivated 
improvements with evaluation and validation. The proof of concept is a testing
tool for testing the implementation correctness of a specification of SUT. The
approach is to start with the lightweight version which can trigger a bug and
test it against the SMT Solver. For the lightweight version, it is an easily
reproducible bug. Then the lightweight version can be improved to a smarter
testing technique to automatically generate tests, these improvements are done
with evaluation and validation. For example, by using existing software testing
techniques like Concolic testing, Fuzz testing and Mutation testing.

\section{Contributions}

\section{Related Work}

\section{Outline}
This discussed the outline of this thesis.
